/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package P2_Interpretador;

/**
 *
 * @author sanqu
 */
public class JPmvn extends javax.swing.JPanel {

    /**
     * Creates new form prueba
     */
    public JPmvn() {
        initComponents();
        initComponentsAux();
        prova();
    }
    
    /**
     * contador de instruções
     */
    int ci=-1;
    
    /**
     * código de operação
     */
    String co="";
    
    /**
     * operando
     */
    String op="";
    
    /**
     * bandeira para detener a execução
     */
    boolean stop=false;
    
    /**
     * bandeira para saber se tem que ler a entrada
     */
    boolean readEntrada=false;
    
    /**
     * Fragmentos de codigo montados
     */
    int loaded=0;

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        endereco = new javax.swing.JTextField();
        reiniciar = new javax.swing.JButton();
        jLabel5 = new javax.swing.JLabel();
        load = new javax.swing.JButton();
        entrada = new javax.swing.JTextField();
        step = new javax.swing.JButton();
        run = new javax.swing.JButton();
        jScrollPane2 = new javax.swing.JScrollPane();
        dados = new javax.swing.JTable();
        saida = new javax.swing.JTextField();
        acomulador = new javax.swing.JTextField();
        jScrollPane3 = new javax.swing.JScrollPane();
        programa = new javax.swing.JTable();
        jLabel1 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        memory = new javax.swing.JTextArea();
        jLabel4 = new javax.swing.JLabel();

        endereco.setFont(new java.awt.Font("Consolas", 0, 13)); // NOI18N
        endereco.setHorizontalAlignment(javax.swing.JTextField.LEFT);
        endereco.setText("000");

        reiniciar.setFont(new java.awt.Font("Consolas", 0, 13)); // NOI18N
        reiniciar.setText("Reset");
        reiniciar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                reiniciarActionPerformed(evt);
            }
        });

        jLabel5.setFont(new java.awt.Font("Consolas", 0, 13)); // NOI18N
        jLabel5.setText("Endereço:");

        load.setFont(new java.awt.Font("Consolas", 0, 13)); // NOI18N
        load.setText("LOAD");
        load.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                loadActionPerformed(evt);
            }
        });

        entrada.setFont(new java.awt.Font("Consolas", 0, 13)); // NOI18N
        entrada.setHorizontalAlignment(javax.swing.JTextField.LEFT);
        entrada.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                entradaActionPerformed(evt);
            }
        });

        step.setFont(new java.awt.Font("Consolas", 0, 13)); // NOI18N
        step.setText("Next Step");
        step.setEnabled(false);
        step.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                stepActionPerformed(evt);
            }
        });

        run.setFont(new java.awt.Font("Consolas", 0, 13)); // NOI18N
        run.setText("RUN");
        run.setEnabled(false);
        run.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                runActionPerformed(evt);
            }
        });

        dados.setFont(new java.awt.Font("Consolas", 0, 13)); // NOI18N
        dados.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null},
                {null, null}
            },
            new String [] {
                "Endereco", "Dado"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.String.class
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }
        });
        jScrollPane2.setViewportView(dados);

        saida.setEditable(false);
        saida.setFont(new java.awt.Font("Consolas", 0, 13)); // NOI18N
        saida.setHorizontalAlignment(javax.swing.JTextField.LEFT);

        acomulador.setEditable(false);
        acomulador.setFont(new java.awt.Font("Consolas", 0, 13)); // NOI18N
        acomulador.setHorizontalAlignment(javax.swing.JTextField.LEFT);
        acomulador.setText("00");

        programa.setFont(new java.awt.Font("Consolas", 0, 13)); // NOI18N
        programa.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null},
                {null, null, null},
                {null, null, null},
                {null, null, null},
                {null, null, null},
                {null, null, null},
                {null, null, null},
                {null, null, null},
                {null, null, null},
                {null, null, null},
                {null, null, null},
                {null, null, null},
                {null, null, null},
                {null, null, null},
                {null, null, null},
                {null, null, null},
                {null, null, null},
                {null, null, null},
                {null, null, null},
                {null, null, null},
                {null, null, null},
                {null, null, null},
                {null, null, null},
                {null, null, null},
                {null, null, null},
                {null, null, null},
                {null, null, null},
                {null, null, null},
                {null, null, null},
                {null, null, null},
                {null, null, null},
                {null, null, null}
            },
            new String [] {
                "CI", "CO", "OP"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.String.class, java.lang.String.class
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }
        });
        jScrollPane3.setViewportView(programa);

        jLabel1.setFont(new java.awt.Font("Consolas", 0, 13)); // NOI18N
        jLabel1.setText("Entrada:");

        jLabel3.setFont(new java.awt.Font("Consolas", 0, 13)); // NOI18N
        jLabel3.setText("Saida:");

        memory.setEditable(false);
        memory.setColumns(20);
        memory.setFont(new java.awt.Font("Consolas", 0, 13)); // NOI18N
        memory.setRows(5);
        memory.setText("");
        memory.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        jScrollPane1.setViewportView(memory);

        jLabel4.setFont(new java.awt.Font("Consolas", 0, 13)); // NOI18N
        jLabel4.setText("Acomulador:");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
                    .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jLabel1)
                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                        .addComponent(jLabel4, javax.swing.GroupLayout.Alignment.TRAILING)
                                        .addComponent(jLabel3)))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addComponent(entrada)
                                    .addComponent(saida)
                                    .addComponent(acomulador, javax.swing.GroupLayout.DEFAULT_SIZE, 49, Short.MAX_VALUE)))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel5)
                                .addGap(18, 18, 18)
                                .addComponent(endereco, javax.swing.GroupLayout.PREFERRED_SIZE, 49, javax.swing.GroupLayout.PREFERRED_SIZE)))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(reiniciar, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                .addGap(0, 0, Short.MAX_VALUE)
                                .addComponent(load, javax.swing.GroupLayout.PREFERRED_SIZE, 95, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(run, javax.swing.GroupLayout.PREFERRED_SIZE, 95, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(step, javax.swing.GroupLayout.PREFERRED_SIZE, 95, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addGap(0, 0, Short.MAX_VALUE)))))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 391, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane1)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 310, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 123, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(entrada, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel1)
                            .addComponent(load))
                        .addGap(4, 4, 4)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(run)
                            .addComponent(jLabel5)
                            .addComponent(endereco, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(step)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(reiniciar))
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(saida, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(jLabel3))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(acomulador, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(jLabel4))))
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents

    /** Método para inicializar as tabelas de programa, dados e memoria.
     */
    private void initComponentsAux(){
        ci=-1;
        co="";
        op="";
        loaded=0;
        stop=false;
        readEntrada=false;
        reiniciar.setEnabled(true);
        load.setEnabled(true);
        run.setEnabled(false);
        step.setEnabled(false);
        saida.setText("");
        entrada.setText("");
        acomulador.setText("00");
        String memorys="    0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f \n";
        for(int i=0; i<256; i++){
            String fil = Integer.toHexString(i);
            if(fil.length()==1) fil="0"+fil;
            memorys=memorys+fil+" XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX\n";            
        }
        memory.setText(memorys);
        memory.setCaretPosition(0);
        for(int i=0; i<32; i++){
            int aux=i*2;
            String hexadecimalaux = Integer.toHexString(aux);
            if(hexadecimalaux.length()==1) this.programa.setValueAt("00"+hexadecimalaux, i, 0);
            if(hexadecimalaux.length()==2) this.programa.setValueAt("0"+hexadecimalaux, i, 0);
            if(hexadecimalaux.length()==3) this.programa.setValueAt(hexadecimalaux, i, 0);
            this.programa.setValueAt("X", i, 1);
            this.programa.setValueAt("XXX", i, 2);
            this.dados.setValueAt("XXX", i, 0);
            this.dados.setValueAt("XX", i, 1);
        }
    }
    
    /** Método para carregar um programa na memoria ja feito, que utiliza todas as funções.
     */
    private void prova(){  
        entrada.setText("44");
        endereco.setText("000");
    }
    
    private void reiniciarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_reiniciarActionPerformed
        initComponentsAux();
    }//GEN-LAST:event_reiniciarActionPerformed

    private void loadActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_loadActionPerformed
        montarEmMemoria();
        this.step.setEnabled(true);
        this.run.setEnabled(true);
    }//GEN-LAST:event_loadActionPerformed

    private void entradaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_entradaActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_entradaActionPerformed

    private void stepActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_stepActionPerformed
        if(ci==-1){
            findInstrution();
        }
        if(readEntrada==true){
            String acoAux = entradaToAcomulador(entrada.getText());
            acomulador.setText(acoAux);
            readEntrada=false;
        }
        if(!co.contains("X")){
            executar();
            nextStep();
            this.load.setEnabled(false);
        }else{
            this.step.setEnabled(false);
            this.run.setEnabled(false);
        }
    }//GEN-LAST:event_stepActionPerformed

    private void runActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_runActionPerformed
        run();
        if(!stop){
            this.step.setEnabled(false);
            this.run.setEnabled(false);
        }else{
            stop=false;
        }

    }//GEN-LAST:event_runActionPerformed


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTextField acomulador;
    private javax.swing.JTable dados;
    private javax.swing.JTextField endereco;
    private javax.swing.JTextField entrada;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    public static javax.swing.JButton load;
    public static javax.swing.JTextArea memory;
    public static javax.swing.JTable programa;
    public static javax.swing.JButton reiniciar;
    public static javax.swing.JButton run;
    private javax.swing.JTextField saida;
    public static javax.swing.JButton step;
    // End of variables declaration//GEN-END:variables
    
    /** Método para executar o programa.
     */
    private void run() {        
        if(ci==-1){
            findInstrution();          
        }
        if(readEntrada==true){            
            String acoAux = entradaToAcomulador(entrada.getText());
            acomulador.setText(acoAux);
            readEntrada=false;
        }
        while(!co.contains("X") && !stop){
            executar();
            nextStep();
            this.load.setEnabled(false);
        }
    }

    /** Método para executar uma instrução.
     */
    private void executar(){
        int a;
        int b;
        switch(co){ 
            case "0":   case "b":  //JP   //RS
                ci=Integer.parseInt(op,16);  
                break; 
            case "1":  //JZ
                if(0==Integer.parseInt(acomulador.getText(),16)){
                    ci=Integer.parseInt(op,16);  
                }else{
                    ci=ci+2;
                }
                break; 
            case "2":  //JN
                if(Integer.parseInt(acomulador.getText().substring(0,1),16)>7){
                    ci=Integer.parseInt(op,16);                    
                }else{
                    ci=ci+2;
                }
                break; 
            case "3":  //LV                
                acomulador.setText((op.substring(1,3)));
                ci=ci+2;
                break; 
            case "4":  //+
                a=getIntTransformed(acomulador.getText());
                b=getIntTransformed(getFromMemory(Integer.parseInt(op, 16)));
                acomulador.setText(getHexTransformed(a+b));
                ci=ci+2;
                break; 
            case "5":  //-
                a=getIntTransformed(acomulador.getText());
                b=getIntTransformed(getFromMemory(Integer.parseInt(op, 16)));
                acomulador.setText(getHexTransformed(a-b));
                ci=ci+2;
                break; 
            case "6":  //*
                a=getIntTransformed(acomulador.getText());
                b=getIntTransformed(getFromMemory(Integer.parseInt(op, 16)));
                acomulador.setText(getHexTransformed(a*b));
                ci=ci+2;
                break; 
            case "7":  ///
                a=getIntTransformed(acomulador.getText());
                b=getIntTransformed(getFromMemory(Integer.parseInt(op, 16)));
                acomulador.setText(getHexTransformed(a/b));
                ci=ci+2;
                break; 
            case "8":  //LD
                acomulador.setText(getFromMemory(Integer.parseInt(op, 16))); 
                ci=ci+2;
                break; 
            case "9":  //MM
                DadoEmMemoria(op, Integer.toString(getIntTransformed(acomulador.getText())));
                ci=ci+2;
                break; 
            case "a":  //SC                
                String ciAux=Integer.toHexString(ci+2);                
                if(ciAux.length()==1) ciAux="00"+ciAux;
                if(ciAux.length()==2) ciAux="0"+ciAux;
                DadoEmMemoria(op, ("0"+ciAux).substring(0, 2));
                DadoEmMemoria(Integer.toHexString(Integer.parseInt(op, 16)+1), ("0"+ciAux).substring(2, 4));
                ci=Integer.parseInt(op, 16)+2;
                break; 
            case "c":  //HM
                stop=true;
                ci=Integer.parseInt(op, 16);
                break; 
            case "d":  //GD
                stop=true;
                readEntrada=true;
                ci=ci+2;
                break; 
            case "e":  //PD
                saida.setText(Integer.toString(getIntTransformed(acomulador.getText())));
                ci=ci+2;
                break; 
            case "f":  //SO
                ci=ci+2;
                break;
            default:
                break;
        }
    }
    
    /** Método para escrever na memoria uma instrução.
     * @param ci String - contador de instruções.
     * @param co String - código de operação.
     * @param op String - operando.
     */
    private void InstrucaoEmMemoria(String ci, String co, String op) {
        String fil = ci.substring(0, 2);
        String col = ci.substring(2);
        setToMemory(fil,col,co+op.substring(0,1));
        int ciInt= Integer.parseInt(ci,16);
        ciInt=ciInt+1;
        String ciHex =Integer.toHexString(ciInt);
        if(ciHex.length()==1) ciHex="00"+ciHex;
        if(ciHex.length()==2) ciHex="0"+ciHex;
        fil = ciHex.substring(0, 2);
        col = ciHex.substring(2);
        setToMemory(fil,col,op.substring(1,3));
    }

    /** Método para escrever na memoria um dado.
     * @param ci String - contador de instruções.
     * @param dado String - dado.
     */
    private void DadoEmMemoria(String ci, String dado) {
        if(ci.length()==1) ci="00"+ci;
        if(ci.length()==2) ci="0"+ci;        
        String fil = ci.substring(0, 2);
        String col = ci.substring(2);        
        setToMemory(fil,col,entradaToAcomulador(dado));
    }
    
    /** Método para obter da memoria um dado.
     * @param fil String - fila da memoria representada em matriz.
     * @param col String - col da memoria representada em matriz.
     * @return String - dado de memoria.
     */
    private String getFromMemory(String fil, String col) {
        int i=Integer.parseInt(fil,16);
        int j=Integer.parseInt(col,16);
        String[] memoryFil = this.memory.getText().split("\n");
        String[] memoryCol = memoryFil[i+1].split(" ");
        return memoryCol[j+1];
    }
    
    /** Método para obter da memoria um dado.
     * @param ci int - endereço.
     * @return String - dado de memoria.
     */
    private String getFromMemory(int ci) {
        String ciHex =Integer.toHexString(ci);
        if(ciHex.length()==1) ciHex="00"+ciHex;
        if(ciHex.length()==2) ciHex="0"+ciHex;
        String fil = ciHex.substring(0, 2);
        String col = ciHex.substring(2);
        return getFromMemory(fil, col);
    }
    
    /** Método para escrever na memoria um dado.
     * @param fil String - fila da memoria representada em matriz.
     * @param col String - col da memoria representada em matriz.
     * @param dado String - dado a ser escrito.
     */
    private void setToMemory(String fil, String col, String dado) {
        String auxMemory="";
        int i=Integer.parseInt(fil,16);
        int j=Integer.parseInt(col,16);
        String[] memoryFil = this.memory.getText().split("\n");
        String[] memoryCol = memoryFil[i+1].split(" ");
        memoryCol[j+1]=dado;
        memoryFil [i+1]=memoryCol[0];
        for(int aux=1;aux<memoryCol.length;aux++){            
            memoryFil[i+1]=memoryFil[i+1]+" "+memoryCol[aux];
        }
        for (String memoryFil1 : memoryFil) {
            auxMemory = auxMemory + memoryFil1 + "\n";
        }
        this.memory.setText(auxMemory);
        this.memory.setCaretPosition(0);
    }

    /** Método para transformar o mnemônico em símbolo de máquina.
     * @param mnemonico String - mnemônico.
     * @return String - símbolo de máquina.
     */
    private String transformarCO(String mnemonico) {        
        switch(mnemonico){ 
            case "jp": case "JP":  return "0";
            case "jz": case "JZ":  return "1";
            case "jn": case "JN":  return "2";
            case "lv": case "LV":  return "3";
            case "+":  return "4";
            case "-":  return "5";
            case "*":  return "6";
            case "/":  return "7";
            case "ld": case "LD":  return "8";
            case "mm": case "MM":  return "9";
            case "sc": case "SC":  return "a";
            case "rs": case "RS":  return "b";
            case "hm": case "HM":  return "c";
            case "gd": case "GD":  return "d";
            case "pd": case "PD":  return "e";
            case "so": case "SO":  return "f";
            default: return mnemonico;
        }
    }

    /** Método para carregar em memoria os dados e o programa (LOADER).
     */
    private void montarEmMemoria() {
        if(loaded<63){
            loaded++;
        }else{
            loaded=0;
        }
        
        for(int i=0; i<32; i++){
            if(this.programa.getValueAt(i, 1)!="X"){                      
                co=transformarCO((String) this.programa.getValueAt(i, 1));
                op=(String) this.programa.getValueAt(i, 2);
                if("3".equals(co)){
                    String aux = entradaToAcomulador(op);
                    if(aux.length()== 2) aux="0"+aux;
                    InstrucaoEmMemoria((String) this.programa.getValueAt(i, 0),co,aux);                    
                }else{
                    InstrucaoEmMemoria((String) this.programa.getValueAt(i, 0),co,op); 
                }
            }
            if(this.dados.getValueAt(i, 0)!="XXX" & this.dados.getValueAt(i, 1)!="XX"){
                DadoEmMemoria((String) this.dados.getValueAt(i, 0),(String) this.dados.getValueAt(i, 1));
            }
        }
        for(int i=0; i<32; i++){
            int aux=((loaded*32+i)*2);
            String hexadecimalaux = Integer.toHexString(aux);
            if(hexadecimalaux.length()==1) this.programa.setValueAt("00"+hexadecimalaux, i, 0);
            if(hexadecimalaux.length()==2) this.programa.setValueAt("0"+hexadecimalaux, i, 0);
            if(hexadecimalaux.length()==3) this.programa.setValueAt(hexadecimalaux, i, 0);     
            this.programa.setValueAt("X", i, 1);
            this.programa.setValueAt("XXX", i, 2);
            this.dados.setValueAt("XXX", i, 0);
            this.dados.setValueAt("XX", i, 1);
        }
    }

    /** Método para procurar a instrução na memoria.
     * muda CI, CO e OP.
     */
    private void findInstrution() {
        String[] memoryFil = this.memory.getText().split("\n");
        String aux0=endereco.getText();
        int aux1=Integer.parseInt(aux0.substring(0, 2), 16);
        int aux2=Integer.parseInt(aux0.substring(2, 3), 16);                     
        ci=(aux1)*16+(aux2);
        String[] memoryCol = memoryFil[aux1+1].split(" ");  
        co=memoryCol[aux2+1].substring(0,1);
        op=memoryCol[aux2+1].substring(1,2)+getFromMemory(ci+1);                
    }

    /** Método para avançar à próxima instrução.
     * muda CO e OP segundo CI.
     */
    private void nextStep() {
        if(ci<4096){
            String ciHex =getFromMemory(ci);
            String ciHex1 =getFromMemory(ci+1);
            co=ciHex.substring(0,1);
            op=ciHex.substring(1,2)+ciHex1;
        }        
    }

    /** Método para transformar um hexadecimal em um binario.
     * @param hex String - Numero hexadecimal.
     * @return String - Numero binario.
     */
    private String hexToBinary(String hex) {
        int aux=Integer.parseInt(hex, 16);
        String binary=Integer.toBinaryString(aux);
        if(binary.length()==1) binary="0000000"+binary;
        if(binary.length()==2) binary="000000"+binary;
        if(binary.length()==3) binary="00000"+binary;
        if(binary.length()==4) binary="0000"+binary;
        if(binary.length()==5) binary="000"+binary;
        if(binary.length()==6) binary="00"+binary;
        if(binary.length()==7) binary="0"+binary;
        return binary;
    }

    /** Método para transformar um binario em um hexadecimal.
     * @param binary String - Numero binario.
     * @return String - Numero hexadecimal.
     */
    private String binaryToHex(String binary) {
        int aux=Integer.parseInt(binary, 2);
        String hex=Integer.toHexString(aux);
        if(hex.length()==1) hex="0"+hex;        
        return hex;
    }

    /** Método para transformar uma entrada do usuario a lenguage de maquina.
     * @param entrada String - entrada em decimal.
     * @return String - Numero hexadecimal tendo em conta se é negativo.
     */
    private String entradaToAcomulador(String entrada) {
        int entradaInt;
        String binary;
        if("-".equals(entrada.substring(0,1))){   //Entrada negativa
            entradaInt = Integer.parseInt(entrada.substring(1));
            binary=Integer.toBinaryString(entradaInt);            
            if(binary.length()==1) binary="1000000"+binary;
            if(binary.length()==2) binary="100000"+binary;
            if(binary.length()==3) binary="10000"+binary;
            if(binary.length()==4) binary="1000"+binary;
            if(binary.length()==5) binary="100"+binary;
            if(binary.length()==6) binary="10"+binary;
            if(binary.length()==7) binary="1"+binary;
            return binaryToHex(binary);
        }else{
            entradaInt = Integer.parseInt(entrada);
            String acoAux=Integer.toHexString(entradaInt);
            if(acoAux.length()==1) acoAux="0"+acoAux;
            return acoAux;
        }
    }

    /** Método para transformar um Hex (negativo ou nao) em entero
     * @return int - Numero entero tendo em conta se é negativo.
     */
    private int getIntTransformed(String hex) {
        String binary = hexToBinary(hex);
        if("1".equals(binary.substring(0,1))){          //acomulador negativo
            return -1*Integer.parseInt(binary.substring(1),2);
        }else{                                          //acomulador positivo
            return Integer.parseInt(binary,2);
        }
    }
    
    /** Método para transformar um entero (negativo ou nao) em Hex de maquina.
     * @return String - Numero hexadecimal tendo em conta se é negativo.
     */
    private String getHexTransformed(int entero){        
        if("-".equals(Integer.toString(entero).substring(0, 1))){
            String binary=Integer.toBinaryString(entero*-1);            
            if(binary.length()==1) binary="1000000"+binary;
            if(binary.length()==2) binary="100000"+binary;
            if(binary.length()==3) binary="10000"+binary;
            if(binary.length()==4) binary="1000"+binary;
            if(binary.length()==5) binary="100"+binary;
            if(binary.length()==6) binary="10"+binary;
            if(binary.length()==7) binary="1"+binary;
            return binaryToHex(binary);
        }else{
            String acoAux=Integer.toHexString(entero);
            if(acoAux.length()==1) acoAux="0"+acoAux;
            return acoAux;            
        }
    }
}
